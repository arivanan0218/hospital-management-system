name: Simple CI/CD Pipeline

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BACKEND: hospital-backend
  ECR_REPOSITORY_FRONTEND: hospital-frontend

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install Python dependencies
      run: |
        cd backend-python
        pip install uv
        uv pip install --system -r pyproject.toml

    - name: Install Node.js dependencies
      run: |
        cd frontend
        npm ci

    - name: Lint frontend code
      run: |
        cd frontend
        npm run lint

    - name: Build frontend
      run: |
        cd frontend
        npm run build

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev'
    
    outputs:
      backend-image: ${{ steps.build-info.outputs.backend-image }}
      frontend-image: ${{ steps.build-info.outputs.frontend-image }}
      image-tag: ${{ steps.build-info.outputs.image-tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push images
      id: build-info
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build and push backend
        echo "Building backend image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG ./backend-python
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest
        
        # Build and push frontend
        echo "Building frontend image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG ./frontend
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest
        
        # Set outputs
        echo "backend-image=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "frontend-image=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy via AWS Systems Manager
      env:
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        VITE_CLAUDE_API_KEY: ${{ secrets.VITE_CLAUDE_API_KEY }}
        VITE_OPENAI_API_KEY: ${{ secrets.VITE_OPENAI_API_KEY }}
        VITE_GROQ_API_KEY: ${{ secrets.VITE_GROQ_API_KEY }}
        VITE_GOOGLE_API_KEY: ${{ secrets.VITE_GOOGLE_API_KEY }}
      run: |
        # Get EC2 instance ID by tag
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=hospital-management-server" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        if [ "$INSTANCE_ID" = "None" ] || [ -z "$INSTANCE_ID" ]; then
          echo "âŒ No running EC2 instance found with tag Name=hospital-management-server"
          exit 1
        fi
        
        echo "ðŸŽ¯ Deploying to instance: $INSTANCE_ID"
        
        # Create a simple deployment script
        cat > /tmp/deploy.sh << 'EOFSCRIPT'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ Starting deployment..."
        
        # Navigate to application directory
        cd /home/ec2-user
        mkdir -p hospital-management
        cd hospital-management
        
        # Login to ECR
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 324037286635.dkr.ecr.us-east-1.amazonaws.com
        
        # Download docker-compose.prod.yml
        curl -o docker-compose.prod.yml https://raw.githubusercontent.com/arivanan0218/hospital-management-system/dev/docker-compose.prod.yml
        
        # Stop existing containers
        docker-compose -f docker-compose.prod.yml down || true
        
        # Pull latest images
        docker pull 324037286635.dkr.ecr.us-east-1.amazonaws.com/hospital-backend:latest
        docker pull 324037286635.dkr.ecr.us-east-1.amazonaws.com/hospital-frontend:latest
        
        # Set environment variables and start containers
        export AWS_ACCOUNT_ID=324037286635
        export AWS_REGION=us-east-1
        export IMAGE_TAG=latest
        export POSTGRES_PASSWORD=HospitalSecure2024!
        export GEMINI_API_KEY=$GEMINI_API_KEY
        
        docker-compose -f docker-compose.prod.yml up -d
        
        # Clean up old images
        docker image prune -f
        
        echo "âœ… Deployment completed successfully"
        EOFSCRIPT
        
        # Upload script to S3 temporarily
        aws s3 cp /tmp/deploy.sh s3://temp-deploy-scripts-$AWS_ACCOUNT_ID/deploy-$IMAGE_TAG.sh || {
          # If S3 bucket doesn't exist, create it and upload
          aws s3 mb s3://temp-deploy-scripts-$AWS_ACCOUNT_ID
          aws s3 cp /tmp/deploy.sh s3://temp-deploy-scripts-$AWS_ACCOUNT_ID/deploy-$IMAGE_TAG.sh
        }
        
        # Execute deployment via SSM using S3 script
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            'aws s3 cp s3://temp-deploy-scripts-$AWS_ACCOUNT_ID/deploy-$IMAGE_TAG.sh /tmp/deploy.sh',
            'chmod +x /tmp/deploy.sh',
            'GEMINI_API_KEY=$GEMINI_API_KEY /tmp/deploy.sh'
          ]" \
          --timeout-seconds 600 \
          --region $AWS_REGION \
          --output text \
          --query 'Command.CommandId')
        
        echo "ðŸ“¡ Command ID: $COMMAND_ID"
        
        # Wait for command completion
        echo "â³ Waiting for deployment to complete..."
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --region $AWS_REGION
        
        # Get command results
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --region $AWS_REGION \
          --query 'StandardOutputContent' \
          --output text
        
        # Clean up S3 script
        aws s3 rm s3://temp-deploy-scripts-$AWS_ACCOUNT_ID/deploy-$IMAGE_TAG.sh

    - name: Verify deployment
      run: |
        # Get instance IP
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=hospital-management-server" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids "$INSTANCE_ID" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "ðŸŒ Application URL: http://$PUBLIC_IP"
        
        # Wait for services to be ready
        echo "â³ Waiting for services to start..."
        sleep 60
        
        # Test health endpoint
        if curl -f "http://$PUBLIC_IP:8000/health"; then
          echo "âœ… Backend health check passed"
        else
          echo "âŒ Backend health check failed"
          exit 1
        fi
        
        # Test frontend
        if curl -f "http://$PUBLIC_IP/"; then
          echo "âœ… Frontend check passed"
        else
          echo "âŒ Frontend check failed"
          exit 1
        fi
        
        echo "ðŸŽ‰ Deployment verification completed successfully!"
        echo "ðŸ“± Access your application at: http://$PUBLIC_IP"
