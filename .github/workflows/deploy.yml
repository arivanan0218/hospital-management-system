name: Hospital Management System CI/CD

on:
  push:
    branches: [ main, dev-aws ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BACKEND: hospital-backend
  ECR_REPOSITORY_FRONTEND: hospital-frontend
  EC2_HOST: 34.207.201.88
  # Environment variables for the entire workflow
  VITE_OPENAI_API_KEY: ${{ secrets.VITE_OPENAI_API_KEY }}
  VITE_LANGSMITH_API_KEY: ${{ secrets.VITE_LANGSMITH_API_KEY }}
  VITE_LANGSMITH_PROJECT: hospital-management-system
  VITE_LANGSMITH_TRACING: true

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        cd backend-python
        pip install uv
        uv pip install --system -e .
    
    - name: Run basic health check
      run: |
        cd backend-python
        python -c "import database; print('âœ… Database module imported successfully')"

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev-aws'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push backend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "ğŸ”¨ Building backend image..."
        cd backend-python
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest .
        echo "ğŸ“¤ Pushing backend image..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest
        echo "âœ… Backend image pushed successfully"

    - name: Create frontend .env file for production
      working-directory: ./frontend
      run: |
        echo "VITE_OPENAI_API_KEY=${{ secrets.VITE_OPENAI_API_KEY }}" > .env
        echo "VITE_LANGSMITH_API_KEY=${{ secrets.VITE_LANGSMITH_API_KEY }}" >> .env
        echo "VITE_LANGSMITH_PROJECT=hospital-management-system" >> .env
        echo "VITE_LANGSMITH_TRACING=true" >> .env
        echo "VITE_MCP_BRIDGE_URL=${{ secrets.VITE_MCP_BRIDGE_URL }}" >> .env
        echo "âœ… Frontend .env file created"

    - name: Build and push frontend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "ğŸ”¨ Building frontend image..."
        cd frontend
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest .
        echo "ğŸ“¤ Pushing frontend image..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest
        echo "âœ… Frontend image pushed successfully"

    - name: Create deployment script
      run: |
        cat > deploy-to-ec2.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ğŸš€ Starting deployment to EC2..."
        
        # More aggressive disk space cleanup
        echo "ğŸ§¹ Performing aggressive disk space cleanup..."
        
        # Stop all containers first to free up resources
        echo "ğŸ›‘ Stopping all Docker containers..."
        sudo docker stop $(sudo docker ps -aq) 2>/dev/null || true
        
        # Remove all stopped containers
        echo "ğŸ—‘ï¸ Removing stopped containers..."
        sudo docker container prune -f || true
        
        # Remove all unused images (not just dangling ones)
        echo "ğŸ—‘ï¸ Removing unused Docker images..."
        sudo docker image prune -af || true
        
        # Remove all unused networks
        echo "ğŸ—‘ï¸ Removing unused Docker networks..."
        sudo docker network prune -f || true
        
        # Remove all unused volumes
        echo "ğŸ—‘ï¸ Removing unused Docker volumes..."
        sudo docker volume prune -f || true
        
        # Complete system prune with volumes
        echo "ğŸ—‘ï¸ Performing complete Docker system cleanup..."
        sudo docker system prune -af --volumes || true
        
        # Clean package manager cache
        echo "ğŸ—‘ï¸ Cleaning package manager cache..."
        sudo apt-get clean || true
        sudo apt-get autoclean || true
        sudo apt-get autoremove -y || true
        
        # Clean temporary files and logs
        echo "ğŸ—‘ï¸ Cleaning temporary files..."
        sudo rm -rf /tmp/* || true
        sudo rm -rf /var/tmp/* || true
        sudo rm -rf /var/lib/apt/lists/* || true
        sudo rm -rf /var/cache/apt/* || true
        
        # Clean log files older than 7 days
        echo "ğŸ—‘ï¸ Cleaning old log files..."
        sudo find /var/log -type f -name "*.log" -mtime +7 -delete 2>/dev/null || true
        sudo find /var/log -type f -name "*.gz" -mtime +7 -delete 2>/dev/null || true
        
        # Clean up any node_modules or build artifacts that might be left
        echo "ğŸ—‘ï¸ Cleaning build artifacts..."
        sudo find /home -name "node_modules" -type d -exec rm -rf {} + 2>/dev/null || true
        sudo find /home -name "dist" -type d -exec rm -rf {} + 2>/dev/null || true
        sudo find /home -name ".cache" -type d -exec rm -rf {} + 2>/dev/null || true
        
        echo "ğŸ’¾ Disk space after aggressive cleanup:"
        df -h
        
        # Check if we have enough space (at least 2GB free)
        available_space=$(df / | tail -1 | awk '{print $4}')
        if [ "$available_space" -lt 2097152 ]; then
          echo "âš ï¸ Warning: Less than 2GB free space available. Consider increasing disk size."
          echo "Available space: ${available_space}KB"
        else
          echo "âœ… Sufficient disk space available: ${available_space}KB"
        fi
        
        # Configure AWS CLI on EC2
        aws configure set region us-east-1
        
        # Login to ECR
        echo "ğŸ” Logging into ECR..."
        aws ecr get-login-password --region us-east-1 | sudo docker login --username AWS --password-stdin 324037286635.dkr.ecr.us-east-1.amazonaws.com
        
        # Pull latest images one at a time to reduce memory pressure
        echo "ğŸ“¥ Pulling backend image..."
        if ! sudo docker pull 324037286635.dkr.ecr.us-east-1.amazonaws.com/hospital-backend:latest; then
          echo "âŒ Failed to pull backend image. Checking disk space..."
          df -h
          exit 1
        fi
        
        echo "ğŸ“¥ Pulling frontend image..."
        if ! sudo docker pull 324037286635.dkr.ecr.us-east-1.amazonaws.com/hospital-frontend:latest; then
          echo "âŒ Failed to pull frontend image. Checking disk space..."
          df -h
          exit 1
        fi
        
        echo "âœ… All images pulled successfully"
        
        # Stop and remove old containers (except database)
        echo "ğŸ›‘ Stopping old containers..."
        sudo docker stop hospital-backend hospital-frontend nginx-proxy 2>/dev/null || true
        sudo docker rm hospital-backend hospital-frontend nginx-proxy 2>/dev/null || true
        
        # Clean up any orphaned containers after stopping
        echo "ğŸ—‘ï¸ Cleaning up orphaned containers..."
        sudo docker container prune -f || true
        
        # Create hospital network if it doesn't exist
        echo "ğŸŒ Creating hospital network..."
        sudo docker network create hospital-network 2>/dev/null || true
        
        # Start PostgreSQL database if not running
        echo "ğŸ—„ï¸ Starting PostgreSQL database..."
        if ! sudo docker ps | grep -q hospital-postgres; then
          # Remove any existing container first
          sudo docker stop hospital-postgres 2>/dev/null || true
          sudo docker rm hospital-postgres 2>/dev/null || true
          sudo docker volume rm hospital-postgres-data 2>/dev/null || true
          
          echo "ğŸ”„ Creating fresh PostgreSQL container..."
          sudo docker run -d \
            --name hospital-postgres \
            --network hospital-network \
            --network-alias postgres \
            --restart unless-stopped \
            -e POSTGRES_DB=hospital_db \
            -e POSTGRES_USER=postgres \
            -e POSTGRES_PASSWORD=postgres \
            postgres:13
            
          echo "â³ Waiting for PostgreSQL to initialize..."
          sleep 30
          
          # Wait for PostgreSQL to be ready
          echo "ğŸ” Checking PostgreSQL readiness..."
          for i in {1..15}; do
            if sudo docker exec hospital-postgres pg_isready -U postgres -d hospital_db > /dev/null 2>&1; then
              echo "âœ… PostgreSQL is ready"
              break
            fi
            echo "â³ Waiting for PostgreSQL... (attempt $i/15)"
            sleep 5
          done
        else
          echo "âœ… PostgreSQL is already running"
          # Ensure existing container has the postgres alias
          sudo docker network disconnect hospital-network hospital-postgres 2>/dev/null || true
          sudo docker network connect --alias postgres hospital-network hospital-postgres 2>/dev/null || true
        fi
        
        # Start new backend container
        echo "ğŸ”„ Starting new backend container..."
        sudo docker run -d \
          --name hospital-backend \
          --network hospital-network \
          --restart unless-stopped \
          -e DATABASE_URL="postgresql://postgres:postgres@postgres:5432/hospital_db" \
          324037286635.dkr.ecr.us-east-1.amazonaws.com/hospital-backend:latest
        
        # Start new frontend container
        echo "ğŸ”„ Starting new frontend container..."
        sudo docker run -d \
          --name hospital-frontend \
          --network hospital-network \
          --restart unless-stopped \
          324037286635.dkr.ecr.us-east-1.amazonaws.com/hospital-frontend:latest
        
        # Setup nginx proxy for routing
        echo "ğŸŒ Setting up nginx proxy..."
        
        # Create nginx configuration
        cat > /tmp/nginx.conf << 'NGINXEOF'
        events {
            worker_connections 1024;
        }
        
        http {
            upstream frontend {
                server hospital-frontend:3000;
            }
            
            upstream backend {
                server hospital-backend:8000;
            }
            
            server {
                listen 80;
                
                # Add CORS headers
                add_header 'Access-Control-Allow-Origin' '*' always;
                add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
                add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' always;
                
                # Health endpoint (route to backend)
                location /health {
                    proxy_pass http://backend;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
                
                # API routes (route to backend)
                location /api/ {
                    proxy_pass http://backend;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
                
                # Tools routes (route to backend) - CRITICAL for MCP server
                location /tools/ {
                    proxy_pass http://backend;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
                
                # Docs routes (route to backend)
                location /docs {
                    proxy_pass http://backend;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
                
                # OpenAPI JSON (route to backend)
                location /openapi.json {
                    proxy_pass http://backend;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
                
                # All other routes (route to frontend)
                location / {
                    proxy_pass http://frontend;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            }
        }
        NGINXEOF
        
        # Stop and remove existing nginx proxy if it exists
        sudo docker stop nginx-proxy 2>/dev/null || true
        sudo docker rm nginx-proxy 2>/dev/null || true
        
        # Start nginx proxy container
        echo "ğŸ”„ Starting nginx proxy..."
        sudo docker run -d \
          --name nginx-proxy \
          --network hospital-network \
          --restart unless-stopped \
          -p 80:80 \
          nginx:alpine
        
        # Copy nginx configuration to container
        sudo docker cp /tmp/nginx.conf nginx-proxy:/etc/nginx/nginx.conf
        
        # Reload nginx configuration
        sudo docker exec nginx-proxy nginx -s reload
        
        # Wait for containers to be healthy
        echo "â³ Waiting for containers to be healthy..."
        sleep 45
        
        # Verify deployment health
        echo "ğŸ” Verifying deployment health..."
        
        # Check container status
        echo "ğŸ“‹ Container status:"
        sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        # Test database connection
        echo "ğŸ—„ï¸ Testing database connection..."
        if sudo docker exec hospital-backend python -c "
        import psycopg2
        try:
            conn = psycopg2.connect('postgresql://postgres:postgres@postgres:5432/hospital_db')
            print('âœ… Database connection successful')
            conn.close()
        except Exception as e:
            print(f'âŒ Database connection failed: {e}')
            exit(1)
        "; then
            echo "âœ… Database connection test passed"
        else
            echo "âš ï¸ Python database test failed, trying PostgreSQL native test..."
            if sudo docker exec hospital-postgres psql -U postgres -d hospital_db -c "SELECT 1;" > /dev/null 2>&1; then
                echo "âœ… PostgreSQL native database test passed"
            else
                echo "âŒ All database tests failed"
                exit 1
            fi
        fi
        
        # Test backend health with retry logic
        echo "ğŸ”§ Testing backend health..."
        for i in {1..15}; do
            if sudo docker exec nginx-proxy wget -q --spider http://hospital-backend:8000/health; then
                echo "âœ… Backend health check passed"
                break
            else
                echo "â³ Backend not ready, attempt $i/15..."
                sleep 10
                if [ $i -eq 15 ]; then
                    echo "âŒ Backend health check failed after 15 attempts"
                    echo "ğŸ” Debugging backend container:"
                    sudo docker logs hospital-backend --tail 20
                    exit 1
                fi
            fi
        done
        
        # Test frontend with retry logic
        echo "ğŸŒ Testing frontend..."
        for i in {1..15}; do
            if sudo docker exec nginx-proxy wget -q --spider http://hospital-frontend:3000; then
                echo "âœ… Frontend health check passed"
                break
            else
                echo "â³ Frontend not ready, attempt $i/15..."
                sleep 10
                if [ $i -eq 15 ]; then
                    echo "âŒ Frontend health check failed after 15 attempts"
                    echo "ğŸ” Debugging frontend container:"
                    sudo docker logs hospital-frontend --tail 20
                    exit 1
                fi
            fi
        done
        
        # Test API endpoints through nginx with extended retry
        echo "ğŸš€ Testing API endpoints through nginx..."
        for i in {1..20}; do
            if sudo docker exec nginx-proxy wget -q -O- http://localhost/health 2>/dev/null | grep -q "status.*healthy"; then
                echo "âœ… API health endpoint accessible through nginx"
                break
            else
                echo "â³ API endpoint not ready through nginx, attempt $i/20..."
                sleep 15
                if [ $i -eq 20 ]; then
                    echo "âŒ API health endpoint not accessible through nginx after 20 attempts"
                    echo "ğŸ” Debugging nginx configuration:"
                    sudo docker exec nginx-proxy cat /etc/nginx/nginx.conf
                    echo "ğŸ” Nginx logs:"
                    sudo docker logs nginx-proxy --tail 20
                    echo "ğŸ” Testing direct backend connection:"
                    sudo docker exec nginx-proxy wget -q -O- http://hospital-backend:8000/health || echo "Direct backend test failed"
                    exit 1
                fi
            fi
        done
        
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸŒ Application is accessible at: http://$(curl -s http://checkip.amazonaws.com/)"
        
        # Check container status first
        echo "ğŸ“‹ Container status:"
        sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        # Check container logs for any immediate issues
        echo "ğŸ“ Backend container logs (last 10 lines):"
        sudo docker logs --tail 10 hospital-backend 2>/dev/null || echo "No backend logs available"
        
        echo "ğŸ“ Frontend container logs (last 10 lines):"
        sudo docker logs --tail 10 hospital-frontend 2>/dev/null || echo "No frontend logs available"
        
        # Test health endpoints through nginx proxy
        echo "ğŸ§ª Testing backend health through nginx proxy..."
        backend_health=false
        if curl -f http://localhost/health 2>/dev/null; then
          echo "âœ… Backend is healthy (through nginx proxy)"
          backend_health=true
        else
          echo "âš ï¸ Backend health check failed through nginx proxy, checking direct access..."
          if curl -f http://hospital-backend:8000/health 2>/dev/null; then
            echo "Backend is healthy directly but nginx routing may have issues"
          elif sudo docker ps | grep -q hospital-backend; then
            echo "Backend container is running but health endpoint not responding"
          fi
        fi
        
        echo "ğŸ§ª Testing frontend availability through nginx proxy..."
        frontend_health=false
        if curl -f http://localhost/ 2>/dev/null; then
          echo "âœ… Frontend is healthy (through nginx proxy)"
          frontend_health=true
        else
          echo "âš ï¸ Frontend health check failed through nginx proxy, checking direct access..."
          if curl -f http://hospital-frontend:3000 2>/dev/null; then
            echo "Frontend is healthy directly but nginx routing may have issues"
          elif sudo docker ps | grep -q hospital-frontend; then
            echo "Frontend container is running but not responding on port 3000"
          fi
        fi
        
        # Overall health check
        if [ "$backend_health" = true ] && [ "$frontend_health" = true ]; then
          echo "âœ… Deployment successful! Both services are healthy."
        else
          echo "âŒ Deployment failed! Health check failed."
          echo "ğŸ” Debugging information:"
          echo "Backend health: $backend_health"
          echo "Frontend health: $frontend_health"
          exit 1
        fi
        
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸŒ Application URL: http://${{ env.EC2_HOST }}/"
        EOF
        
        chmod +x deploy-to-ec2.sh

    - name: Deploy to EC2
      env:
        PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        HOST: ${{ env.EC2_HOST }}
        USER: ubuntu
      run: |
        echo "ğŸ” Setting up SSH..."
        echo "$PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        echo "ğŸ“ Copying deployment script to EC2..."
        scp -i private_key.pem -o StrictHostKeyChecking=no deploy-to-ec2.sh $USER@$HOST:~/
        
        echo "ğŸš€ Executing deployment on EC2..."
        ssh -i private_key.pem -o StrictHostKeyChecking=no $USER@$HOST '
          chmod +x ~/deploy-to-ec2.sh
          ~/deploy-to-ec2.sh
        '
        
        echo "ğŸ§¹ Cleaning up..."
        rm -f private_key.pem

    - name: Final health check
      run: |
        echo "ğŸ” Final health check..."
        sleep 10
        if curl -f http://${{ env.EC2_HOST }}/health; then
          echo ""
          echo "ğŸ‰ âœ… DEPLOYMENT SUCCESSFUL! âœ… ğŸ‰"
          echo "ğŸŒ Your Hospital Management System is live at: http://${{ env.EC2_HOST }}/"
          echo "ğŸ¥ Health API: http://${{ env.EC2_HOST }}/health"
          echo "ğŸ“š Documentation: http://${{ env.EC2_HOST }}/docs"
        else
          echo "âŒ Final health check failed"
          exit 1
        fi
